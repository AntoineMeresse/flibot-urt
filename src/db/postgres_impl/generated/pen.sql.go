// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: pen.sql

package postgres_genererated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPen = `-- name: CreatePen :one
INSERT INTO pen (guid, date, size)
VALUES ($1, $2, $3)
RETURNING id, guid, date, size
`

type CreatePenParams struct {
	Guid string
	Date pgtype.Date
	Size float64
}

func (q *Queries) CreatePen(ctx context.Context, arg CreatePenParams) (Pen, error) {
	row := q.db.QueryRow(ctx, createPen, arg.Guid, arg.Date, arg.Size)
	var i Pen
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.Date,
		&i.Size,
	)
	return i, err
}

const getAllPenByDate = `-- name: GetAllPenByDate :many
SELECT pen.id, pen.guid, pen.date, pen.size, player.name
FROM pen
JOIN player ON pen.guid = player.guid
WHERE date = $1
ORDER BY size DESC
LIMIT $2
`

type GetAllPenByDateParams struct {
	Date  pgtype.Date
	Limit int32
}

type GetAllPenByDateRow struct {
	ID   int32
	Guid string
	Date pgtype.Date
	Size float64
	Name string
}

func (q *Queries) GetAllPenByDate(ctx context.Context, arg GetAllPenByDateParams) ([]GetAllPenByDateRow, error) {
	rows, err := q.db.Query(ctx, getAllPenByDate, arg.Date, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPenByDateRow
	for rows.Next() {
		var i GetAllPenByDateRow
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.Date,
			&i.Size,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPensOrderBySizeAsc = `-- name: GetPensOrderBySizeAsc :many
SELECT pen.id, pen.guid, pen.date, pen.size, player.name
FROM pen
JOIN player ON pen.guid = player.guid
WHERE EXTRACT(YEAR FROM date) = EXTRACT(YEAR FROM $1::date)
ORDER BY size ASC
LIMIT $2
`

type GetPensOrderBySizeAscParams struct {
	Column1 pgtype.Date
	Limit   int32
}

type GetPensOrderBySizeAscRow struct {
	ID   int32
	Guid string
	Date pgtype.Date
	Size float64
	Name string
}

func (q *Queries) GetPensOrderBySizeAsc(ctx context.Context, arg GetPensOrderBySizeAscParams) ([]GetPensOrderBySizeAscRow, error) {
	rows, err := q.db.Query(ctx, getPensOrderBySizeAsc, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPensOrderBySizeAscRow
	for rows.Next() {
		var i GetPensOrderBySizeAscRow
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.Date,
			&i.Size,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPensOrderBySizeDesc = `-- name: GetPensOrderBySizeDesc :many
SELECT pen.id, pen.guid, pen.date, pen.size, player.name
FROM pen
JOIN player ON pen.guid = player.guid
WHERE EXTRACT(YEAR FROM date) = EXTRACT(YEAR FROM $1::date)
ORDER BY size DESC
LIMIT $2
`

type GetPensOrderBySizeDescParams struct {
	Column1 pgtype.Date
	Limit   int32
}

type GetPensOrderBySizeDescRow struct {
	ID   int32
	Guid string
	Date pgtype.Date
	Size float64
	Name string
}

func (q *Queries) GetPensOrderBySizeDesc(ctx context.Context, arg GetPensOrderBySizeDescParams) ([]GetPensOrderBySizeDescRow, error) {
	rows, err := q.db.Query(ctx, getPensOrderBySizeDesc, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPensOrderBySizeDescRow
	for rows.Next() {
		var i GetPensOrderBySizeDescRow
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.Date,
			&i.Size,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerPenByDate = `-- name: GetPlayerPenByDate :one
SELECT size
FROM pen
WHERE guid = $1 AND date = $2
`

type GetPlayerPenByDateParams struct {
	Guid string
	Date pgtype.Date
}

func (q *Queries) GetPlayerPenByDate(ctx context.Context, arg GetPlayerPenByDateParams) (float64, error) {
	row := q.db.QueryRow(ctx, getPlayerPenByDate, arg.Guid, arg.Date)
	var size float64
	err := row.Scan(&size)
	return size, err
}
