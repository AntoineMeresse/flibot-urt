// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: pen.sql

package postgres_genererated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const decrementPenAttempts = `-- name: DecrementPenAttempts :execrows
UPDATE pen SET attempts = GREATEST(attempts - 1, 0)
WHERE guid = $1 AND date = $2
`

type DecrementPenAttemptsParams struct {
	Guid string
	Date pgtype.Date
}

func (q *Queries) DecrementPenAttempts(ctx context.Context, arg DecrementPenAttemptsParams) (int64, error) {
	result, err := q.db.Exec(ctx, decrementPenAttempts, arg.Guid, arg.Date)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAllPenByDate = `-- name: GetAllPenByDate :many
SELECT pen.id, pen.guid, pen.date, pen.size, pen.attempts, player.name
FROM pen
JOIN player ON pen.guid = player.guid
WHERE date = $1
ORDER BY size DESC
LIMIT $2
`

type GetAllPenByDateParams struct {
	Date  pgtype.Date
	Limit int32
}

type GetAllPenByDateRow struct {
	ID       int32
	Guid     string
	Date     pgtype.Date
	Size     float64
	Attempts int32
	Name     string
}

func (q *Queries) GetAllPenByDate(ctx context.Context, arg GetAllPenByDateParams) ([]GetAllPenByDateRow, error) {
	rows, err := q.db.Query(ctx, getAllPenByDate, arg.Date, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPenByDateRow
	for rows.Next() {
		var i GetAllPenByDateRow
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.Date,
			&i.Size,
			&i.Attempts,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPensOrderBySizeAsc = `-- name: GetPensOrderBySizeAsc :many
SELECT pen.id, pen.guid, pen.date, pen.size, pen.attempts, player.name
FROM pen
JOIN player ON pen.guid = player.guid
WHERE EXTRACT(YEAR FROM date) = EXTRACT(YEAR FROM $1::date)
ORDER BY size ASC
LIMIT $2
`

type GetPensOrderBySizeAscParams struct {
	Column1 pgtype.Date
	Limit   int32
}

type GetPensOrderBySizeAscRow struct {
	ID       int32
	Guid     string
	Date     pgtype.Date
	Size     float64
	Attempts int32
	Name     string
}

func (q *Queries) GetPensOrderBySizeAsc(ctx context.Context, arg GetPensOrderBySizeAscParams) ([]GetPensOrderBySizeAscRow, error) {
	rows, err := q.db.Query(ctx, getPensOrderBySizeAsc, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPensOrderBySizeAscRow
	for rows.Next() {
		var i GetPensOrderBySizeAscRow
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.Date,
			&i.Size,
			&i.Attempts,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPensOrderBySizeDesc = `-- name: GetPensOrderBySizeDesc :many
SELECT pen.id, pen.guid, pen.date, pen.size, pen.attempts, player.name
FROM pen
JOIN player ON pen.guid = player.guid
WHERE EXTRACT(YEAR FROM date) = EXTRACT(YEAR FROM $1::date)
ORDER BY size DESC
LIMIT $2
`

type GetPensOrderBySizeDescParams struct {
	Column1 pgtype.Date
	Limit   int32
}

type GetPensOrderBySizeDescRow struct {
	ID       int32
	Guid     string
	Date     pgtype.Date
	Size     float64
	Attempts int32
	Name     string
}

func (q *Queries) GetPensOrderBySizeDesc(ctx context.Context, arg GetPensOrderBySizeDescParams) ([]GetPensOrderBySizeDescRow, error) {
	rows, err := q.db.Query(ctx, getPensOrderBySizeDesc, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPensOrderBySizeDescRow
	for rows.Next() {
		var i GetPensOrderBySizeDescRow
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.Date,
			&i.Size,
			&i.Attempts,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerPenByDate = `-- name: GetPlayerPenByDate :one
SELECT size
FROM pen
WHERE guid = $1 AND date = $2
`

type GetPlayerPenByDateParams struct {
	Guid string
	Date pgtype.Date
}

func (q *Queries) GetPlayerPenByDate(ctx context.Context, arg GetPlayerPenByDateParams) (float64, error) {
	row := q.db.QueryRow(ctx, getPlayerPenByDate, arg.Guid, arg.Date)
	var size float64
	err := row.Scan(&size)
	return size, err
}

const getYearlyAttempts = `-- name: GetYearlyAttempts :one
SELECT COALESCE(SUM(attempts), 0)::integer
FROM pen
WHERE guid = $1 AND EXTRACT(YEAR FROM date) = EXTRACT(YEAR FROM $2::date)
`

type GetYearlyAttemptsParams struct {
	Guid    string
	Column2 pgtype.Date
}

func (q *Queries) GetYearlyAttempts(ctx context.Context, arg GetYearlyAttemptsParams) (int32, error) {
	row := q.db.QueryRow(ctx, getYearlyAttempts, arg.Guid, arg.Column2)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const upsertPen = `-- name: UpsertPen :one
INSERT INTO pen (guid, date, size, attempts)
VALUES ($1, $2, $3, 1)
ON CONFLICT (guid, date) DO UPDATE SET
    size = EXCLUDED.size,
    attempts = pen.attempts + 1
RETURNING id, guid, date, size, attempts
`

type UpsertPenParams struct {
	Guid string
	Date pgtype.Date
	Size float64
}

func (q *Queries) UpsertPen(ctx context.Context, arg UpsertPenParams) (Pen, error) {
	row := q.db.QueryRow(ctx, upsertPen, arg.Guid, arg.Date, arg.Size)
	var i Pen
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.Date,
		&i.Size,
		&i.Attempts,
	)
	return i, err
}
